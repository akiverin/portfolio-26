---
description: "Performance — lazy loading, tree-shaking, MobX optimization, bundle size"
globs: ["src/**/*.ts", "src/**/*.tsx"]
alwaysApply: false
---

# Performance & Optimization

## Lazy Loading Pages

All pages MUST be lazy-loaded in `RouterProvider`:

```typescript
const ServersPage = React.lazy(() => import('pages/ServersPage/ui/ServersPage'));
const VolumesPage = React.lazy(() => import('pages/VolumesPage/ui/VolumesPage'));
```

## No Barrel Files at Segment Level

**CRITICAL**: Barrel files (`index.ts`) that aggregate multiple modules break tree-shaking.

```typescript
// ❌ DON'T — kills tree-shaking, pulls in everything
// features/volume/index.ts
export * from './ui/VolumeCreateModal';
export * from './ui/VolumeEditModal';
export * from './model/VolumeCreateModalStore';

// ✅ DO — import directly from module
import VolumeCreateModal from 'features/volume/ui/VolumeCreateModal';
```

## Tabler Icons — ESM Import

The project aliases `@tabler/icons-react` to its ESM build for tree-shaking:

```typescript
// ✅ DO — named imports (tree-shaken via ESM alias)
import { IconServer, IconTrash } from '@tabler/icons-react';

// ❌ DON'T — deep imports are unnecessary due to alias
import { IconServer } from '@tabler/icons-react/dist/esm/icons/IconServer';
```

## MobX Computed Values

Use `computed` for derived data — MobX caches results and only recalculates when dependencies change:

```typescript
makeObservable(this, {
  filteredServers: computed,
  totalCount: computed,
});

get filteredServers(): ServerSchema[] {
  return this._servers.filter(s => s.state === this._filter);
}
```

## Abort Controllers

Cancel in-flight requests when:
- Component unmounts (via `destroy()`)
- User triggers a new request (search, filter change)
- Navigation away from page

```typescript
async load(): Promise<void> {
  this._abortController.abort();
  this._abortController = new AbortController();
  // ...
}

destroy(): void {
  this._abortController.abort();
}
```

## Debounced Search/Filter

Use debounce for user-triggered filtering to avoid excessive API calls:

```typescript
import { debounce } from 'shared/utils/debounce';

constructor() {
  this._debouncedLoad = debounce(this.load, 300);
  this._disposers.push(
    reaction(() => this.search.value, () => this._debouncedLoad()),
  );
}
```

## Polling

For real-time data (server status, VM state transitions), use `PollingStore` or `CallbackIntervalStore` from shared:

```typescript
import { PollingStore } from 'shared/stores/PollingStore';

readonly polling = new PollingStore({
  callback: () => this.load(),
  interval: 5000,
});
```

Always stop polling in `destroy()`.

## DON'T

- Don't eagerly import pages — always `React.lazy()`
- Don't create segment-level barrels — they prevent tree-shaking
- Don't forget to abort/cancel in `destroy()`
- Don't run expensive computations in render — move to MobX `computed`
- Don't poll without cleanup — stop intervals in `destroy()`
